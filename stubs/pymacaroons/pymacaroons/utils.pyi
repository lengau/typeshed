from _typeshed import ReadableBuffer
from typing import overload

@overload
def convert_to_bytes(string_or_bytes: None) -> None: ...
@overload
def convert_to_bytes(string_or_bytes: str | bytes) -> bytes: ...
@overload
def convert_to_string(string_or_bytes: None) -> None: ...
@overload
def convert_to_string(string_or_bytes: str | bytes) -> str: ...
def truncate_or_pad(byte_string: bytes, size: int | None = None) -> bytes: ...
def generate_derived_key(key: ReadableBuffer | None) -> bytes: ...
def hmac_digest(key: bytes | bytearray, data: ReadableBuffer | None) -> bytes: ...
def hmac_hex(key: bytes | bytearray, data: ReadableBuffer | None) -> bytes: ...
def create_initial_signature(key: ReadableBuffer | None, identifier: ReadableBuffer | None) -> bytes: ...
def hmac_concat(key: bytes | bytearray, data1: ReadableBuffer | None, data2: ReadableBuffer | None) -> bytes: ...
def sign_first_party_caveat(signature: bytes | bytearray, predicate: ReadableBuffer | None): ...
def sign_third_party_caveat(
    signature: bytes | bytearray, verification_id: ReadableBuffer | None, caveat_id: ReadableBuffer | None
) -> bytes: ...
def equals(val1: str | bytes | bytearray, val2: str | bytes | bytearray) -> bool: ...
def add_base64_padding(b: bytes) -> bytes: ...
def raw_b64decode(s: str) -> bytes: ...
def raw_urlsafe_b64decode(s: str) -> bytes: ...
def raw_urlsafe_b64encode(b: bytes) -> bytes: ...
